input {  
  stdin { 
  }
}

filter{
  mutate {
      add_field => [ "logSource", "httpd" ]
      remove_field => "host"
  }

  grok {
    patterns_dir => ["C:\Users\troussetj\Documents\git\devtools\scripts\seph\elk\patterns"]
    match => {
      "message" => "(%{SERVERNAME}%{SPACE})?(.%{URIPATHPARAM:logFilePath}:)?%{IPORHOST:clientip} - - \[%{HTTPDATE:logtimestamp}\] %{NUMBER:responseTime} \"%{WORD:verb} %{NOTSPACE:request} HTTP/%{NUMBER:httpversion}\" %{QS:referer} %{QS:userAgent} %{NUMBER:httpCode} %{NUMBER:bytes} %{IP:ip} %{QS:sessionId} %{QS:host}"
    }
  }

  if !("" in [server]) {
    mutate {
      add_field => [ "server", "%$serverName$%" ]
    }
  }

  mutate {
    gsub => [

      "sessionId", "^\"", "",
      "sessionId", "\"$", "",
      "referer", "^\"", "",
      "referer", "\"$", "",
      "userAgent", "^\"", "",
      "userAgent", "\"$", "",
      "sessionId", "^\"", "",
      "sessionId", "\"$", "",
      "host", "^\"", "",
      "host", "\"$", ""

    ]
  }

  date {
      #[20/Sep/2016:18:44:55 +0200]
    locale => "en"
    match => [ "logtimestamp" , "dd/MMM/yyyy:HH:mm:ss Z" ]
    target => "@timestamp"
  }
}
#generate the fingerprint from all the fields (instead of the message because the format can change depending on the source)
filter { 
    ruby {
        init => "require 'digest/sha1'; require 'json'"
        code => "event['fingerprint'] = Digest::SHA1.hexdigest event.to_json"
    }
}

output {
  #prettyprint
  stdout {
    codec => "rubydebug"
  }
  
  elasticsearch {
    hosts => "http://localhost:9200"
    index => "logstash-seph"
    document_id => "%{fingerprint}"
  }
}
