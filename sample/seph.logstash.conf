input {  
  stdin { 
  }
}

# #generate id from the whole message
# filter {
#   fingerprint {
#     method => "SHA1"
#     key => "KEY"
#   }
# }
#remove windows linebreaks
filter {
  mutate {
    gsub => [ "message", "\r", "" ]
  }
}
filter{
  #agregate lines that don't start with "[serverName]? timestamp"
  multiline {
    patterns_dir => ["C:\Users\troussetj\Documents\git\devtools\scripts\seph\elk\patterns"]
    pattern => "^(%{SERVERNAME}%{SPACE})?20%{TIMESTAMP_ISO8601}"
    negate => true
    what => "previous"
  }
  #main filter
  #java stacktraces
  #standard logline
  grok {
    patterns_dir => ["C:\Users\troussetj\Documents\git\devtools\scripts\seph\elk\patterns"]
    match => {
      #order from more to less complex
      #end with a greedy pattern to catch multilines that are not parsable yet
      "message" => [
          "(?m)^%{STD_LOG_LINE}%{EXCEPTION_LINE}%{STACKTRACE:stacktrace}$",
          "^%{STD_LOG_LINE}$",
          "(?m)^%{STD_LOG_LINE}%{GREEDYDATA:postfix}$"
        ]
       # overwrite => [ "message" ]
    }
  }
  if !("" in [server]) {
    mutate {
      add_field => [ "server", "%$serverName$%" ]
    }
  }
  #later to add apache logs as well
  mutate {
      add_field => [ "logSource", "jboss" ]
  }

  date {
      #2016-09-22 06:14:55,978
    locale => "en"
    match => [ "logtimestamp" , "YY-MM-dd HH:mm:ss,SSS" ]
    target => "@timestamp"
  }

#extract status change
  grok {
    patterns_dir => ["C:\Users\troussetj\Documents\git\devtools\scripts\seph\elk\patterns"]
    match => {
      "logMessage" => "Moving status code for order %{ORDERID} from %{NUMBER:fromStatusCode} to %{NUMBER:toStatusCode}"
    }
    add_field => { "logType" => "statusCodeChange"}
    tag_on_failure => []
  }

#extract item ids
   grok {
    patterns_dir => ["C:\Users\troussetj\Documents\git\devtools\scripts\seph\elk\patterns"]
    break_on_match => false
    match => {
      "logMessage" => [
        "order %{ORDERID}",
        "%{USER}",
        "%{PAYMENTGROUP:paymentGroup}",
        "%{SHIPPINGGROUP:shippingGroup}",
        "%{COMMERCEITEM:commerceItem}",
        "%{IP:ip}",
        "Session Id : %{URIHOST:sessionId}"
      ]
    }
    tag_on_failure => []
  }
}
#generate the fingerprint from all the fields (instead of the message because the format can change depending on the source)
filter { 
    ruby {
        init => "require 'digest/sha1'; require 'json'"
        code => "event['fingerprint'] = Digest::SHA1.hexdigest event.to_json"
    }
}

output {
  #prettyprint
  stdout {
    codec => "rubydebug"
  }
  
  elasticsearch {
    hosts => "http://localhost:9200"
    index => "logstash-seph"
    document_id => "%{fingerprint}"
  }
}
